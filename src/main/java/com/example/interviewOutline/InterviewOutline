一、基础篇
1.1 java基础
    1.面向对象的特征:继承、封装和多态
        继承可以拓展和复用父类的属性和方法，和重写配合使用实现java的多态，
        封装隐藏内部实现细节，对外提供api,做到模块之间的解耦
        多态：父类对象指向子类对象引用，子类对象重写父类方法
    2.final, finally, finalize 的区别
        final修饰类，方法，属性表示类不可被继承，方法不可被重写，属性不能改变
        finally 通常在try/catch 结尾结尾，做一些流资源/socket连接的关闭，释放资源
        finalize 跟gc相关，如果对象在finalize块中被引用，可能会延迟这个对象的回收
    3.Exception、Error、运行时异常与一般异常有何异同
        异常是程序允许的，允许程序做一些补救措施，分为运行时异常和非运行时异常，error是错误，
        程序无法处理，比如虚拟机异常oom，stackOverFlow这些，
        不同点：非运行时异常编译阶段会直接报错的，比如io读文件错误，sqlException,用户自定义异常，
        运行时异常就是一般的空指针，数组越界，classCastException，VerifyException
    4.请写出5种常见到的runtime exception
        nullPointException. IndexOutOfBoundException, ClassCastException,
        IllegalArgumentException, ArithmeticException,ArrayStoreException,
        NumberFormatException
    5.int 和 Integer 有什么区别，Integer的值缓存范围
        包装类型的基本类型，-128～127
    6.包装类，装箱和拆箱
        byte, short, int, long   Byte,  Short, Integer, Long
        boolean, char, float, double  Boolean, Character. Float, Double
        Number类是一个抽象类，返回基本类型
    7.String、StringBuilder、StringBuffer
        String是final类型的，StringBuild是线程不安全，非final的 Buffer是线程安全非final类目前似乎被废弃了
    8.重载和重写的区别
        重载跟原来的方法方法名相同，参数和参数类型可以不同， 重写跟原来的方法名参数和参数类型都是一致的，一般子类重写父类的方法
    9.抽象类和接口有什么区别
        抽象类可以有自己的实现，除了不能实例化，抽象类和普通的类没区别的，一个不是抽象类的类继承一个抽象类，要实现他的所有抽象方法
        当然抽象类也可以继承抽象类， 一个类可以实现一个接口，需要实现这个接口的所有方法，  还有一点就是接口和类的区别了，
        可以实现多个接口， 但是只能继承一个类
    10.Java中的泛型方法
        泛型提供擦除机制，编译的字节码是没有泛型的，List<>来说  限定了类型，比以前不带类型形参的方式更安全
    11.说说反射的用途及实现
        各种ide，框架会比较多的用到反射，动态代理，比如spring的xml配置，先用forName,或者ClassLoader获取这个类，判断是否
        是我们需要的类，实例化，通过需要执行方法的invoke方法传入参数来执行方法，或者直接拿到他的属性
    12.说说自定义注解的场景及实现
        jpa中类属性跟表字段自动对应赋值， @Notnull验证功能，javadoc
        有4个元注解， @interface就可以生成注解 注解可以有自己的字段
    13.HTTP请求的GET与POST方式的区别
        get请求参数接在url后面，安全性不高，有最大长度限制，  post请求安全性高， 参数通过requestBody传递到后台，没有最大长度限制
    14.Session与Cookie区别
        session是服务端保存的客户端状态 一般重要的信息比如登录密码保存在session中，当访问增多时，会影响服务器性能
        cookie是客户端保存的服务端状态，有最大长度限制，3k，不可靠，保存在本地，时间比较长，3个月不用重新登录就是cookie的一个应用
    15.列出自己常用的JDK包
        java.lang java.math java.sql java.io java.util java.nio
    16.MVC设计思想
        model,view,controller, model负责封装业务逻辑， view负责展现视图，提供用户的操作界面
        controller负责帮view发过来的请求找到相应的model处理
    17.equals与==的区别
        equal不需要比较对象地址，对象内容相同就返回true， ==还需要比较对象内存地址，指针指向同一块区域才算相等
    18.hashCode和equals方法的区别与联系
        hashCode不可靠，不同的对象也可能会生成同样的hash码。 equals的比较方法更可靠一点，在集合或者hashMap中比较的时候会
        先比较hashCode，如果hashcode相等在比较equals
        重写equals方法，要重写hashCode方法,
    19.什么是Java序列化和反序列化，如何实现Java序列化?或者请解释Serializable 接口的作用
        将一个对象序列化，使其变成二进制字节流形式，便于在网络上传输和存储到磁盘，反序列化是让其从二进制字节流形式变为对象形式，
        实现Serializable
    20.Object类中常见的方法，为什么wait notify会放在Object里边?
        toString(), equals, hashCode, wait, notify
        唤醒，等待必须是同一把锁，因为锁的定义可以是任何一个对象， 所以 wait, notify就放在对象里面了
    21.Java的平台无关性如何体现出来的
        jvm
    22.JDK和JRE的区别
        jdk饱含java开发工具包和jre，jre只是java运行环境
    23.Java 8有哪些新特性
        增加lambda函数式编程,接口默认方法和静态方法，容器功能增强，流式编程， localDateTime, 重复注解

1.2、Java常见集合
    List 和 Set 区别
    Set和hashCode以及equals方法的联系
    List 和 Map 区别
    ArrayList 与 LinkedList 区别
    ArrayList 与 Vector 区别
    HashMap 和 HashTable 的区别
    HashSet 和 HashMap 区别
    HashMap 和 ConcurrentHashMap 的区别
    HashMap 的工作原理及代码实现，什么时候用到红黑树
    多线程情况下HashMap死循环的问题
    HashMap出现Hash DOS攻击的问题
    ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数
    手写简单的HashMap
    看过那些Java集合类的源码
    迭代器Iterator相比其他集合类的好处在哪

1.3、进程和线程
    线程和进程的概念、并行和并发的概念
    创建线程的方式及实现
    进程间通信的方式
    说说 CountDownLatch、CyclicBarrier 原理和区别
    说说 Semaphore 原理
    说说 Exchanger 原理
    ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理
    InheritableThreadLocal原理分析
    多线程日志追踪实现 traceId
    讲讲线程池的实现原理
    线程池的几种实现方式
    线程的生命周期，状态是如何转移的

1.4、锁机制
    说说线程安全问题，什么是线程安全，如何保证线程安全
    重入锁的概念，重入锁为什么可以防止死锁
    产生死锁的四个条件(互斥、请求与保持、不剥夺、循环等待)
    如何检查死锁(通过jConsole检查死锁)
    volatile 实现原理(禁止指令重排、刷新内存)
    synchronized 实现原理(对象监视器)
    synchronized 与 lock 的区别
        1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
        2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
        3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
        4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
        5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
        6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
    AQS同步队列
    CAS无锁的概念、乐观锁和悲观锁
    常见的原子操作类
    什么是ABA问题，出现ABA问题JDK是如何解决的
    乐观锁的业务场景及实现方式
    Java 8并法包下常见的并发类
    偏向锁、轻量级锁、重量级锁、自旋锁的概念

1.5、JVM
    JVM运行时内存区域划分
    内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决
    如何判断对象是否可以回收或存活
    常见的GC回收算法及其含义
    常见的JVM性能监控和故障处理工具类:jps、jstat、jmap、jinfo、jconsole等
    JVM如何设置参数
    JVM性能调优
    类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的
    类加载的过程:加载、验证、准备、解析、初始化
    强引用、软引用、弱引用、虚引用
    Java内存模型JMM

1.6、设计模式
    常见的设计模式
    设计模式的的六大原则及其含义
    常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式
    设计模式在实际场景中的应用
    Spring中用到了哪些设计模式
    MyBatis中用到了哪些设计模式
    你项目中有使用哪些设计模式
    说说常用开源框架中设计模式使用分析
    动态代理很重要!!!

1.7、数据结构
    树(二叉查找树、平衡二叉树、红黑树、B树、B+树)
    深度有限算法、广度优先算法
    克鲁斯卡尔算法、普林母算法、迪克拉斯算法
    什么是一致性Hash及其原理、Hash环问题
    常见的排序算法和查找算法:快排、折半查找、堆排序等

1.8、网络/IO基础
    BIO、NIO、AIO的概念
    什么是长连接和短连接
    Http1.0和2.0相比有什么区别
    Https的基本概念
    三次握手和四次挥手、为什么挥手需要四次
    从游览器中输入URL到页面加载的发生了什么?

1.9、 拦截器和过滤器
    先说一下servlet容器，过滤器是servlet容器管理的，容器下面就是过滤器，过滤器里面是servlet,
    拦截器是spring框架管理的， 在handler前后可以自定义拦截方法

二、数据存储和消息队列

2.1、数据库

    MySQL 索引使用的注意事项
        1.不要在sql里面做任何计算，计算会导致不走索引， 2.like %号要放后面， 3.不能使用or， 4.不能使用正则，
        5.字符串不能跟数字比较，数字也不能跟字符串比较， 6.判断是否为null会不走索引因为索引不能存储null值
    DDL、DML、DCL分别指什么
        DDL, definition 数据库定义语言，建表删表语句等  DML manipulation 数据操纵语言，一般的增删改查，
        DCL  control 数据库控制语言，一般用来设置权限
    explain命令
        sql执行计划，我一般用来看它有没有使用索引，
    left join，right join，inner join
        以左边为基础，
    数据库事物ACID(原子性、一致性、隔离性、持久性)
        原子性：一个事务要么执行成功，要么不执行，没有中间状态. 一致性:不破坏数据库的完整性约束，执行前和完成后数据库约束不变，
        也包含执行逻辑要正确， 隔离性：多个事务之间应该互不影响， 持久性: 事务完成保存到磁盘 持久化
    事物的隔离级别(读未提交、读以提交、可重复读、可序列化读)
        脏读：读了一个事务未完全提交的值.不可重复读:两次读数据不一致. 可重复读:可能造成幻读. 序列化读:最稳的
    脏读、幻读、不可重复读
    数据库的几大范式
        第一范式：列的原子性， 第二范式：所有列都和主键关联， 第三范式:所有列都和主键直接关联
    数据库常见的命令
        增删改查
    说说分库与分表设计
        纵向分表:主表，辅助表，  横向分表:单表数据量太大
    分库与分表带来的分布式困境与应对之策(如何解决分布式下的分库分表，全局表?)
    说说 SQL 优化之道
        避免索引失效，尽量使用数字型字段，字符型的多用varchar, 避免使用select * , 批提交sql
    MySQL遇到的死锁问题、如何排查与解决
        jConsole
    存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
        InnoDB行级锁支持高并发，提供事务机制， MyISAM表级锁，并发很差，适合查询很多改动很少的场景
    索引类别(B+树索引、全文索引、哈希索引)、索引的原理
        B+树，平衡多叉树，适合范围查询， 哈希索引，等值查询，快速定位到单个哈系值key
    什么是自适应哈希索引(AHI)
    为什么要用 B+tree作为MySQL索引的数据结构
        平衡树，查找的效率是O(log(n))
    聚集索引与非聚集索引的区别
    遇到过索引失效的情况没，什么时候可能会出现，如何解决
        第一条答案
    limit 20000 加载很慢怎么解决
        查询之前记录他的最大ID limit你需要的数据
    如何选择合适的分布式主键方案
    选择合适的数据存储方案
    常见的几种分布式ID的设计方案
    常见的数据库优化方案，在你的项目中数据库如何进行优化的

2.2、Redis

    Redis 有哪些数据类型
        string, list, set, sorted set, hash
    Redis 内部结构
        Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），
        事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）
        提供高可用性（High Availability）
    Redis 使用场景
        高速缓存，分布式锁.
    Redis 持久化机制
        RDB和AOF
    Redis 集群方案与实现
        主从，master挂掉，选举新的slave为master， 原先master正常后以slave身份重新加入
    Redis 为什么是单线程的?
        基于内存的，查找效率很高，所以不需要多线程，单线程的优势在于避免线程的上下文切换，也不用考虑各种锁的加锁与释放以及死锁问题。
    缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级
    使用缓存的合理性问题
    Redis常见的回收策略
        LRU,最近最少使用的key先进行清理
    redis主从是怎么选取的
        选举机制
    redis插槽的分配
        每一个key通过hash映射成一个槽位，set值的时候通过槽位拿到所有节点，进行赋值操作
    redis复制的过程
        slaveOf, master拷贝rdb到slave
    redis主节点宕机了怎么办，还有没有同步的数据怎么办
        slave会升级到master, 通过aof恢复
    重入锁是怎么计数的
        同一个线程多次获得锁，计数器+1 释放锁-1， 就是说多一个线程不会多次竞争同一把分布式锁.

2.3、消息队列

    消息队列的使用场景
    消息的重发补偿解决思路
    消息的幂等性解决思路
    消息的堆积解决思路
    自己如何实现消息队列
    如何保证消息的有序性

三、开源框架和容器

3.1、SSM/Servlet

    1.Servlet的生命周期
        加载，实例化先调用init方法初始化，有请求进来调用service()方法，最后容器关闭或者该servlet不可用调用他的destroy方法
        整个生命周期内只初始化一次
    2.转发与重定向的区别
        转发：
        请求服务器内部流转，一个请求，setAttribute和 getAttribute来传递参数
        重定向：
        两个请求，两个响应，互不影响，用getParameter方法传递参数
    3.request.getParam 和 request.getAttribute方法
        链接关系用getParameter，转发关系用set/getAttribute
    4.BeanFactory 和 ApplicationContext 有什么区别
        beanFactory是spring最底层的接口，只提供了实例化和获取bean的功能
        applicationContext 由 beanFactory接口派生来的，更面向框架化，提供了很多功能，从xml,file去拿bean之类的，还会一次性
        加载创建所有bean，在容器启动的时候能及时排查到bean的配置错误 也可以手动设置Bean的懒加载
    5.Spring Bean 的生命周期
        容器启动，由BeanFactory 或者 applicationContext初始化和实例化，最后destroy 销毁
    6.Spring IOC 如何实现
        BeanFactory/ApplicationContext是IOC的两种实现,
        先实例化IOC容器, getBean获取实例，通过BeanDefinition在IOC容器注册
    7.Spring中Bean的作用域，默认的是哪一个
        默认是singleton, 其他还有prototype, session, request
    8.说说 Spring AOP、Spring AOP 实现原理
        核心是动态代理加反射
    9.动态代理(CGLib 与 JDK)、优缺点、性能对比、如何选择
        jdk代理接口的实现类，基于接口的， cglib是生成代理类的子类，代理类不能为final类型的，cglib proxy创建慢运行快
        ，jdk proxy刚好相反选择方面，如果类有顶层接口，选择jdk，如果直接是一个类使用cglib
    10.Spring 事务实现方式、事务的传播机制、默认的事务类别
        编程式事务，显示调用commit, rollback等命令， 用的比较多的声明式事务，注解形式，或者用aop方式声明事务
        事务传播机制，常用的就是require,当前没有事务，创建一个事务，当前已经存在事务，加入事务， 默认事务类别应该指的
        就是这个require吧
    11.Spring 事务底层原理
        通过aop实现切面逻辑织入的，能保证任何一个事务任何一个方法失败调用db rollback回滚事务
    12.Spring事务失效(事务嵌套)，JDK动态代理给Spring事务埋下的坑
        两个带有@Trasaction注解的方法，如果A直接调用B 相当与调用普通B的方法，除非开启proxy
        SpringBoot配置方式：注解开启 exposeProxy = true 否则((xxxService)AopContext.currentProxy())
        .methodB()暴露代理对象;
    13.如何自定义注解实现功能
    14.Spring MVC 运行流程
    15.Spring MVC 启动流程
    16.Spring 的单例实现原理
    17.Spring 框架中用到了哪些设计模式
    18.Spring 其他产品(Spring Boot、Spring Cloud、Spring Security、Spring Data、Spring AMQP 等)
    19.有没有用到Spring Boot，Spring Boot的认识、原理
    20.MyBatis的原理

3.2、Netty

    为什么选择 Netty
    说说业务中，Netty 的使用场景
    原生的 NIO 在 JDK 1.7 版本存在 epoll bug
    什么是TCP 粘包/拆包
    TCP粘包/拆包的解决办法
    Netty 线程模型
    说说 Netty 的零拷贝
    Netty 内部执行流程
    Netty 重连实现

3.3、Tomcat

    Tomcat的基础架构(Server、Service、Connector、Container)
    Tomcat如何加载Servlet的
    Pipeline-Valve机制

四、分布式

4.1、Nginx

    1.请解释什么是C10K问题或者知道什么是C10K问题吗?
        服务器无法并发处理10000以上的连接情况， epoll异步非阻塞处理等待kernel准备数据阶段的socket的并行数
    2.Nginx简介
        支持高并发的反向代理服务器，实现负载均衡
    3.正向代理和反向代理.
        正向代理代理客户端， 反向代理代理服务端
    4.Nginx几种常见的负载均衡策略
        1.默认轮询 2.加权轮询 3.fair根据服务器响应时间 4.ip_hash 5.url_hash
    5.Nginx服务器上的Master和Worker进程分别是什么
        master控制nginx服务器，fork出来的worker进程负责处理实际请求
    6.使用“反向代理服务器”的优点是什么?
        微服务分发拦截请求，负载均衡，增加机器负载
    7.nginx 框架是怎样的
        https://blog.csdn.net/guolong1983811/article/details/53501251
        master+worker多进程模型，反向代理分发请求，底层epoll处理多个socket连接
    8.nginx负载均衡的算法怎么实现的
        轮询按时间分配请求，weight按权重，iphash按ip地址分配请求，能保证一个用户总是访问一台服务器解决了session共享问题，
        fair根据服务器响应时间来分配请求，url_hash根据url计算哈希值定位到后台服务器
    9.如何解决惊群现象？
        nginx解决惊群问题是多个worker进程都去抢占进程锁，拿到锁的才进行处理

4.2、分布式其他

    谈谈业务中使用分布式的场景
    Session 分布式方案
    Session 分布式处理
    分布式锁的应用场景、分布式锁的产生原因、基本概念
    分布是锁的常见解决方案
    分布式事务的常见解决方案
    集群与负载均衡的算法与实现
    说说分库与分表设计
    分库与分表带来的分布式困境与应对之策

4.3、Dubbo

    什么是Dubbo
    什么是RPC、如何实现RPC、RPC 的实现原理
    Dubbo中的SPI是什么概念
    Dubbo的基本原理、执行流程

五、微服务

5.1、微服务

    前后端分离是如何做的?
    微服务哪些框架
    Spring Could的常见组件有哪些?
    领域驱动有了解吗?什么是领域驱动模型?充血模型、贫血模型
    JWT有了解吗，什么是JWT
    你怎么理解 restful
    说说如何设计一个良好的 API
    如何理解 restful API 的幂等性
    如何保证接口的幂等性
    说说 CAP 定理、BASE 理论
    怎么考虑数据一致性问题
    说说最终一致性的实现方案
    微服务的优缺点
    微服务与 SOA 的区别
    如何拆分服务、水平分割、垂直分割
    如何应对微服务的链式调用异常
    如何快速追踪与定位问题
    如何保证微服务的安全、认证

5.2、安全问题

    如何防范常见的Web攻击、如何方式SQL注入
    服务端通信安全攻防
    HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

5.3、性能优化

    性能指标有哪些
    如何发现性能瓶颈
    性能调优的常见手段
    说说你在项目中如何进行性能调优

六、其他

6.1、设计能力

    说说你在项目中使用过的UML图
    你如何考虑组件化、服务化、系统拆分
    秒杀场景如何设计

6.2、业务工程

    说说你的开发流程、如何进行自动化部署的
    你和团队是如何沟通的
    你如何进行代码评审
    说说你对技术与业务的理解
    说说你在项目中遇到感觉最难Bug，是如何解决的
    介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

6.3、软实力

    说说你的优缺点、亮点
    说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码
    说说你觉得最有意义的技术书籍
    工作之余做什么事情、平时是如何学习的，怎样提升自己的能力
    说说个人发展方向方面的思考
    说说你认为的服务端开发工程师应该具备哪些能力
    说说你认为的架构师是什么样的，架构师主要做什么
    如何看待加班的问题
